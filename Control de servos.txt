#include <p18f4520.h>
#include <stdlib.h>	
#include <delays.h>
#include <usart.h>

#pragma config OSC = INTIO67
#pragma config PWRT = ON, BOREN = SBORDIS, BORV = 3
#pragma config WDT = OFF
#pragma config MCLRE = ON, PBADEN = ON, CCP2MX = PORTC
#pragma config STVREN = ON, LVP = OFF

unsigned int  dato,Value,Value2,State,Initialservo;
float Servo,Pixelx;	//Direccion del esclavo

//unsigned long dato1,dato2;	// Variable en la que se almacenará el resultado de la conversión


void R_Int_Alta(void);  // Declaración de la subrutina de tratamiento de interrupciones de alta prioridad

// Retardos necesarios para el LCD
void DelayFor18TCY(void){Delay10TCYx(2);}	// Retardo de 18 ciclos
void DelayPORXLCD(void){Delay1KTCYx(15);}	// Retardo de 15ms
void DelayXLCD(void){Delay1KTCYx(5);}		// Retardo de 5ms

#pragma code Vector_Int_Alta=0x08  // Vectorización de las interrupciones de alta prioridad
void Int_Alta (void)
{
    _asm GOTO R_Int_Alta _endasm
}
#pragma code

#pragma interrupt R_Int_Alta  // Rutina de tratamiento de las interrupciones de alta prioridad
void R_Int_Alta (void)
{
    if (INTCONbits.TMR0IF==1) // Check if interrupt is caused by timer 0 overflow
    {
        INTCONbits.TMR0IF=0; // Interrupt flag is reset to ?0'
        
        switch (State)
        {
            case 1:
                PORTBbits.RB7=1;
                TMR0H=Value/256; // TMR0H and TMR0L are reload with the initial value corresponding to 1,5ms
                TMR0L=Value%256;
                State=2;
                break;
                
            case 2:
                PORTBbits.RB7=0;
                TMR0H=Value2/256; // TMR0H and TMR0L are reload with the initial value corresponding to 20ms
                TMR0L=Value2%256; // TMR0=65536-(TINTERVALO/TT0)=65536-(20000·E-6*4·E6)/4)=45536
                State=1;
                break;
        }
    }


    else if (PIR1bits.RCIF) 		// Se comprueba si la interrupción ha sido por recepción
    {
    	//dato = ReadUSART(); 	// Se almacena el dato leído en la posición correspondiente del bufer
        
    }
}

void main(void)		// Programa principal
{
    Delay10KTCYx(50);
    TRISA=0xF1;                 // RB0, RB1 y RB2 de salida

    OSCCONbits.IRCF0=0;
    OSCCONbits.IRCF1=1;
    OSCCONbits.IRCF2=1;

    OpenUSART (USART_TX_INT_OFF & USART_RX_INT_ON & USART_ASYNCH_MODE
            & USART_EIGHT_BIT & USART_CONT_RX & USART_BRGH_HIGH,25);

    // Se configura la USART en modo 8 bits, sin paridad, 1 Stop bit,  9600 baud
    // e interr. de recepción habilitada
    // Vel. Com.= Fosc/(16*(SPBREG+1))=4000000/(16*(25+1))=9615



    TRISA=0b10000111; // Input A
    TRISB=0b00000000;


    ADCON1=0b00001100; // Analogue inputs A0 and A1 and A2
    ADCON2=0b10010001; //right; 4*T; FOSC/4 (T=1us)

    T0CON=0x88;	// Timer 0 modo temp. de 16 bits. Prescalar (por lo visto desactivado [88]). TIMER ON
	TMR0H=65536/256;	// Se carga el valor de TMR0H y TMR0L para un intervalo de 1s
	TMR0L=65536%256;	// TMR0=65536-(TINT*FOSC/4*PRES)=65536-(1s*65534Hz(que he puesto yo))/4*1(disabled))=???? =0x0002
    INTCONbits.GIE=1; // Interrupts are enabled globally
	INTCONbits.TMR0IE=1; // Se habilita la interrupción del Temporizador 0
    
    State=1;
    dato=640;
    Servo=dato*25/16;

    Delay10KTCYx(50);

    //gotoxyLCD(1,1); putrsXLCD("LED ROJO OFF");
    //gotoxyLCD(1,2); putrsXLCD("LED VERDE OFF");

    while(1)	// Bucle principal
    {

        Value=65536-(1000+875/3+Servo*5/12-28);
        Value2=65536-(20000-Servo*5/12);
    }
}

